// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: run_function.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Duration } from "./google/protobuf/duration.js";
import { Struct } from "./google/protobuf/struct.js";

export const protobufPackage = "apiextensions.fn.proto.v1";

/** Ready indicates whether a resource should be considered ready. */
export enum Ready {
  READY_UNSPECIFIED = 0,
  /** READY_TRUE - True means the resource has been observed to be ready. */
  READY_TRUE = 1,
  /** READY_FALSE - False means the resource has not been observed to be ready. */
  READY_FALSE = 2,
  UNRECOGNIZED = -1,
}

export function readyFromJSON(object: any): Ready {
  switch (object) {
    case 0:
    case "READY_UNSPECIFIED":
      return Ready.READY_UNSPECIFIED;
    case 1:
    case "READY_TRUE":
      return Ready.READY_TRUE;
    case 2:
    case "READY_FALSE":
      return Ready.READY_FALSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Ready.UNRECOGNIZED;
  }
}

export function readyToJSON(object: Ready): string {
  switch (object) {
    case Ready.READY_UNSPECIFIED:
      return "READY_UNSPECIFIED";
    case Ready.READY_TRUE:
      return "READY_TRUE";
    case Ready.READY_FALSE:
      return "READY_FALSE";
    case Ready.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Severity of function results. */
export enum Severity {
  SEVERITY_UNSPECIFIED = 0,
  /**
   * SEVERITY_FATAL - Fatal results are fatal; subsequent functions may run, but the function
   * pipeline run will be considered a failure and the first fatal result will
   * be returned as an error.
   */
  SEVERITY_FATAL = 1,
  /**
   * SEVERITY_WARNING - Warning results are non-fatal; the entire pipeline will run to completion
   * but warning events and debug logs associated with the XR or Operation will
   * be emitted.
   */
  SEVERITY_WARNING = 2,
  /**
   * SEVERITY_NORMAL - Normal results are emitted as normal events and debug logs associated with
   * the XR or operation.
   */
  SEVERITY_NORMAL = 3,
  UNRECOGNIZED = -1,
}

export function severityFromJSON(object: any): Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "SEVERITY_FATAL":
      return Severity.SEVERITY_FATAL;
    case 2:
    case "SEVERITY_WARNING":
      return Severity.SEVERITY_WARNING;
    case 3:
    case "SEVERITY_NORMAL":
      return Severity.SEVERITY_NORMAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}

export function severityToJSON(object: Severity): string {
  switch (object) {
    case Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Severity.SEVERITY_FATAL:
      return "SEVERITY_FATAL";
    case Severity.SEVERITY_WARNING:
      return "SEVERITY_WARNING";
    case Severity.SEVERITY_NORMAL:
      return "SEVERITY_NORMAL";
    case Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Target of function results and conditions. */
export enum Target {
  /** TARGET_UNSPECIFIED - If the target is unspecified, the result targets the XR. */
  TARGET_UNSPECIFIED = 0,
  /**
   * TARGET_COMPOSITE - Target the XR. Results that target the XR should include detailed, advanced
   * information.
   */
  TARGET_COMPOSITE = 1,
  /**
   * TARGET_COMPOSITE_AND_CLAIM - Target the XR and the claim. Results that target the XR and the claim
   * should include only end-user friendly information.
   */
  TARGET_COMPOSITE_AND_CLAIM = 2,
  UNRECOGNIZED = -1,
}

export function targetFromJSON(object: any): Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return Target.TARGET_UNSPECIFIED;
    case 1:
    case "TARGET_COMPOSITE":
      return Target.TARGET_COMPOSITE;
    case 2:
    case "TARGET_COMPOSITE_AND_CLAIM":
      return Target.TARGET_COMPOSITE_AND_CLAIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Target.UNRECOGNIZED;
  }
}

export function targetToJSON(object: Target): string {
  switch (object) {
    case Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case Target.TARGET_COMPOSITE:
      return "TARGET_COMPOSITE";
    case Target.TARGET_COMPOSITE_AND_CLAIM:
      return "TARGET_COMPOSITE_AND_CLAIM";
    case Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Status {
  STATUS_CONDITION_UNSPECIFIED = 0,
  STATUS_CONDITION_UNKNOWN = 1,
  STATUS_CONDITION_TRUE = 2,
  STATUS_CONDITION_FALSE = 3,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_CONDITION_UNSPECIFIED":
      return Status.STATUS_CONDITION_UNSPECIFIED;
    case 1:
    case "STATUS_CONDITION_UNKNOWN":
      return Status.STATUS_CONDITION_UNKNOWN;
    case 2:
    case "STATUS_CONDITION_TRUE":
      return Status.STATUS_CONDITION_TRUE;
    case 3:
    case "STATUS_CONDITION_FALSE":
      return Status.STATUS_CONDITION_FALSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_CONDITION_UNSPECIFIED:
      return "STATUS_CONDITION_UNSPECIFIED";
    case Status.STATUS_CONDITION_UNKNOWN:
      return "STATUS_CONDITION_UNKNOWN";
    case Status.STATUS_CONDITION_TRUE:
      return "STATUS_CONDITION_TRUE";
    case Status.STATUS_CONDITION_FALSE:
      return "STATUS_CONDITION_FALSE";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A RunFunctionRequest requests that the function be run. */
export interface RunFunctionRequest {
  /** Metadata pertaining to this request. */
  meta:
    | RequestMeta
    | undefined;
  /**
   * The observed state prior to invocation of a function pipeline. State passed
   * to each function is fresh as of the time the pipeline was invoked, not as
   * of the time each function was invoked.
   */
  observed:
    | State
    | undefined;
  /**
   * Desired state according to a function pipeline. The state passed to a
   * particular function may have been accumulated by previous functions in the
   * pipeline.
   *
   * Note that the desired state must be a partial object with only the fields
   * that this function (and its predecessors in the pipeline) wants to have set
   * in the object. Copying a non-partial observed state to desired is most
   * likely not what you want to do. Leaving out fields that had been returned
   * as desired before will result in them being deleted from the objects in the
   * cluster.
   */
  desired:
    | State
    | undefined;
  /**
   * Optional input specific to this function invocation. A JSON representation
   * of the 'input' block of the relevant entry in a function pipeline.
   */
  input?:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional context. Crossplane may pass arbitrary contextual information to a
   * function. A function may also return context in its RunFunctionResponse,
   * and that context will be passed to subsequent functions. Crossplane
   * discards all context returned by the last function in the pipeline.
   */
  context?:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional resources that the function specified in its requirements. Note
   * that resources is a map to Resources, plural. The map key corresponds to
   * the key in a RunFunctionResponse's requirements.extra_resources field. If a
   * function requested extra resources that did not exist, Crossplane sets
   * the map key to an empty Resources message to indicate that it attempted to
   * satisfy the request. This field is only populated when the function uses
   * extra_resources in its requirements.
   *
   * Deprecated: Use required_resources instead.
   *
   * @deprecated
   */
  extraResources: { [key: string]: Resources };
  /**
   * Optional credentials that this function may use to communicate with an
   * external system.
   */
  credentials: { [key: string]: Credentials };
  /**
   * Optional resources that the function specified in its requirements. Note
   * that resources is a map to Resources, plural. The map key corresponds to
   * the key in a RunFunctionResponse's requirements.resources field. If a
   * function requested required resources that did not exist, Crossplane sets
   * the map key to an empty Resources message to indicate that it attempted to
   * satisfy the request. This field is only populated when the function uses
   * resources in its requirements.
   */
  requiredResources: { [key: string]: Resources };
}

export interface RunFunctionRequest_ExtraResourcesEntry {
  key: string;
  value: Resources | undefined;
}

export interface RunFunctionRequest_CredentialsEntry {
  key: string;
  value: Credentials | undefined;
}

export interface RunFunctionRequest_RequiredResourcesEntry {
  key: string;
  value: Resources | undefined;
}

/** Credentials that a function may use to communicate with an external system. */
export interface Credentials {
  /** Credential data loaded by Crossplane, for example from a Secret. */
  credentialData?: CredentialData | undefined;
}

/** CredentialData loaded by Crossplane, for example from a Secret. */
export interface CredentialData {
  data: { [key: string]: Buffer };
}

export interface CredentialData_DataEntry {
  key: string;
  value: Buffer;
}

/** Resources represents the state of several Crossplane resources. */
export interface Resources {
  items: Resource[];
}

/** A RunFunctionResponse contains the result of a function run. */
export interface RunFunctionResponse {
  /** Metadata pertaining to this response. */
  meta:
    | ResponseMeta
    | undefined;
  /**
   * Desired state according to a function pipeline. functions may add desired
   * state, and may mutate or delete any part of the desired state they are
   * concerned with. A function must pass through any part of the desired state
   * that it is not concerned with.
   *
   * Note that the desired state must be a partial object with only the fields
   * that this function (and its predecessors in the pipeline) wants to have set
   * in the object. Copying a non-partial observed state to desired is most
   * likely not what you want to do. Leaving out fields that had been returned
   * as desired before will result in them being deleted from the objects in the
   * cluster.
   */
  desired:
    | State
    | undefined;
  /** Results of the function run. Results are used for observability purposes. */
  results: Result[];
  /**
   * Optional context to be passed to the next function in the pipeline as part
   * of the RunFunctionRequest. Dropped on the last function in the pipeline.
   */
  context?:
    | { [key: string]: any }
    | undefined;
  /** Requirements that must be satisfied for this function to run successfully. */
  requirements:
    | Requirements
    | undefined;
  /**
   * Status conditions to be applied to the XR. Conditions may also optionally
   * be applied to the XR's associated claim.
   *
   * Conditions are only used for composition. They're ignored by Operations.
   */
  conditions: Condition[];
  /**
   * Optional output specific to this function invocation.
   *
   * Only Operations use function output. XRs will discard any function output.
   */
  output?: { [key: string]: any } | undefined;
}

/** RequestMeta contains metadata pertaining to a RunFunctionRequest. */
export interface RequestMeta {
  /**
   * An opaque string identifying a request. Requests with identical tags will
   * be otherwise identical.
   */
  tag: string;
}

/** Requirements that must be satisfied for a function to run successfully. */
export interface Requirements {
  /**
   * Resources that this function requires. The map key uniquely identifies the
   * group of resources.
   *
   * Deprecated: Use resources instead.
   *
   * @deprecated
   */
  extraResources: { [key: string]: ResourceSelector };
  /**
   * Resources that this function requires. The map key uniquely identifies the
   * group of resources.
   */
  resources: { [key: string]: ResourceSelector };
}

export interface Requirements_ExtraResourcesEntry {
  key: string;
  value: ResourceSelector | undefined;
}

export interface Requirements_ResourcesEntry {
  key: string;
  value: ResourceSelector | undefined;
}

/** ResourceSelector selects a group of resources, either by name or by label. */
export interface ResourceSelector {
  /** API version of resources to select. */
  apiVersion: string;
  /** Kind of resources to select. */
  kind: string;
  /** Match the resource with this name. */
  matchName?:
    | string
    | undefined;
  /** Match all resources with these labels. */
  matchLabels?:
    | MatchLabels
    | undefined;
  /**
   * Match resources in this namespace. Omit namespace to match cluster scoped
   * resources, or to match namespaced resources by labels across all
   * namespaces.
   */
  namespace?: string | undefined;
}

/** MatchLabels defines a set of labels to match resources against. */
export interface MatchLabels {
  labels: { [key: string]: string };
}

export interface MatchLabels_LabelsEntry {
  key: string;
  value: string;
}

/** ResponseMeta contains metadata pertaining to a RunFunctionResponse. */
export interface ResponseMeta {
  /**
   * An opaque string identifying the content of the request. Must match the
   * meta.tag of the corresponding RunFunctionRequest.
   */
  tag: string;
  /**
   * Time-to-live of this response. Crossplane will call the function again when
   * the TTL expires. Crossplane may cache the response to avoid calling the
   * function again until the TTL expires.
   */
  ttl?: Duration | undefined;
}

/** State of the XR (XR) and any resources. */
export interface State {
  /** The state of the XR (XR). */
  composite:
    | Resource
    | undefined;
  /**
   * The state of any other resources. In composition functions these are the
   * composed resources. In operation functions they're arbitrary resources that
   * the operation wants to create or update.
   */
  resources: { [key: string]: Resource };
}

export interface State_ResourcesEntry {
  key: string;
  value: Resource | undefined;
}

/** A Resource represents the state of a Kubernetes resource. */
export interface Resource {
  /**
   * The JSON representation of the resource.
   *
   * * Crossplane will set this field in a RunFunctionRequest to the entire
   * observed state of a resource - including its metadata, spec, and status.
   *
   * * A function should set this field in a RunFunctionRequest to communicate
   * the desired state of the resource.
   *
   * * A function may only specify the desired status of a XR - not its metadata
   * or spec. A function should not return desired metadata or spec for a XR.
   * This will be ignored.
   *
   * * A function may not specify the desired status of any other resource -
   * e.g. composed resources. It may only specify their metadata and spec.
   * Status will be ignored.
   */
  resource:
    | { [key: string]: any }
    | undefined;
  /**
   * The resource's connection details.
   *
   * * Crossplane will set this field in a RunFunctionRequest to communicate the
   * the observed connection details of a composite or composed resource.
   *
   * * A function should set this field in a RunFunctionResponse to indicate the
   * desired connection details of the XR.
   *
   * * A function should not set this field in a RunFunctionResponse to indicate
   * the desired connection details of a composed resource. This will be
   * ignored.
   *
   * Connection details are only used for composition. They're ignored by
   * Operations.
   */
  connectionDetails: { [key: string]: Buffer };
  /**
   * Ready indicates whether the resource should be considered ready.
   *
   * * Crossplane will never set this field in a RunFunctionRequest.
   *
   * * A function should set this field to READY_TRUE in a RunFunctionResponse
   * to indicate that a desired resource is ready.
   *
   * * A function should set this field to READY_TRUE in a RunFunctionResponse
   * to indicate that a desired XR is ready. This overwrites the standard
   * readiness detection that determines the ready state of the composite by the
   * ready state of the the composed resources.
   *
   * Ready is only used for composition. It's ignored by Operations.
   */
  ready: Ready;
}

export interface Resource_ConnectionDetailsEntry {
  key: string;
  value: Buffer;
}

/** A Result of running a function. */
export interface Result {
  /** Severity of this result. */
  severity: Severity;
  /** Human-readable details about the result. */
  message: string;
  /**
   * Optional PascalCase, machine-readable reason for this result. If omitted,
   * the value will be ComposeResources.
   */
  reason?:
    | string
    | undefined;
  /** The resources this result targets. */
  target?: Target | undefined;
}

/**
 * Status condition to be applied to the XR. Condition may also optionally be
 * applied to the XR's associated claim. For detailed information on proper
 * usage of status conditions, please see
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties.
 */
export interface Condition {
  /** Type of condition in PascalCase. */
  type: string;
  /** Status of the condition. */
  status: Status;
  /**
   * Reason contains a programmatic identifier indicating the reason for the
   * condition's last transition. Producers of specific condition types may
   * define expected values and meanings for this field, and whether the values
   * are considered a guaranteed API. The value should be a PascalCase string.
   * This field may not be empty.
   */
  reason: string;
  /**
   * Message is a human readable message indicating details about the
   * transition. This may be an empty string.
   */
  message?:
    | string
    | undefined;
  /** The resources this condition targets. */
  target?: Target | undefined;
}

function createBaseRunFunctionRequest(): RunFunctionRequest {
  return {
    meta: undefined,
    observed: undefined,
    desired: undefined,
    input: undefined,
    context: undefined,
    extraResources: {},
    credentials: {},
    requiredResources: {},
  };
}

export const RunFunctionRequest: MessageFns<RunFunctionRequest> = {
  encode(message: RunFunctionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      RequestMeta.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.observed !== undefined) {
      State.encode(message.observed, writer.uint32(18).fork()).join();
    }
    if (message.desired !== undefined) {
      State.encode(message.desired, writer.uint32(26).fork()).join();
    }
    if (message.input !== undefined) {
      Struct.encode(Struct.wrap(message.input), writer.uint32(34).fork()).join();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(42).fork()).join();
    }
    Object.entries(message.extraResources).forEach(([key, value]) => {
      RunFunctionRequest_ExtraResourcesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.credentials).forEach(([key, value]) => {
      RunFunctionRequest_CredentialsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.requiredResources).forEach(([key, value]) => {
      RunFunctionRequest_RequiredResourcesEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = RequestMeta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.observed = State.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desired = State.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.input = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = RunFunctionRequest_ExtraResourcesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.extraResources[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = RunFunctionRequest_CredentialsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.credentials[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = RunFunctionRequest_RequiredResourcesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.requiredResources[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest {
    return {
      meta: isSet(object.meta) ? RequestMeta.fromJSON(object.meta) : undefined,
      observed: isSet(object.observed) ? State.fromJSON(object.observed) : undefined,
      desired: isSet(object.desired) ? State.fromJSON(object.desired) : undefined,
      input: isObject(object.input) ? object.input : undefined,
      context: isObject(object.context) ? object.context : undefined,
      extraResources: isObject(object.extraResources)
        ? Object.entries(object.extraResources).reduce<{ [key: string]: Resources }>((acc, [key, value]) => {
          acc[key] = Resources.fromJSON(value);
          return acc;
        }, {})
        : {},
      credentials: isObject(object.credentials)
        ? Object.entries(object.credentials).reduce<{ [key: string]: Credentials }>((acc, [key, value]) => {
          acc[key] = Credentials.fromJSON(value);
          return acc;
        }, {})
        : {},
      requiredResources: isObject(object.requiredResources)
        ? Object.entries(object.requiredResources).reduce<{ [key: string]: Resources }>((acc, [key, value]) => {
          acc[key] = Resources.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RunFunctionRequest): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = RequestMeta.toJSON(message.meta);
    }
    if (message.observed !== undefined) {
      obj.observed = State.toJSON(message.observed);
    }
    if (message.desired !== undefined) {
      obj.desired = State.toJSON(message.desired);
    }
    if (message.input !== undefined) {
      obj.input = message.input;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.extraResources) {
      const entries = Object.entries(message.extraResources);
      if (entries.length > 0) {
        obj.extraResources = {};
        entries.forEach(([k, v]) => {
          obj.extraResources[k] = Resources.toJSON(v);
        });
      }
    }
    if (message.credentials) {
      const entries = Object.entries(message.credentials);
      if (entries.length > 0) {
        obj.credentials = {};
        entries.forEach(([k, v]) => {
          obj.credentials[k] = Credentials.toJSON(v);
        });
      }
    }
    if (message.requiredResources) {
      const entries = Object.entries(message.requiredResources);
      if (entries.length > 0) {
        obj.requiredResources = {};
        entries.forEach(([k, v]) => {
          obj.requiredResources[k] = Resources.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunFunctionRequest>, I>>(base?: I): RunFunctionRequest {
    return RunFunctionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFunctionRequest>, I>>(object: I): RunFunctionRequest {
    const message = createBaseRunFunctionRequest();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? RequestMeta.fromPartial(object.meta)
      : undefined;
    message.observed = (object.observed !== undefined && object.observed !== null)
      ? State.fromPartial(object.observed)
      : undefined;
    message.desired = (object.desired !== undefined && object.desired !== null)
      ? State.fromPartial(object.desired)
      : undefined;
    message.input = object.input ?? undefined;
    message.context = object.context ?? undefined;
    message.extraResources = Object.entries(object.extraResources ?? {}).reduce<{ [key: string]: Resources }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Resources.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.credentials = Object.entries(object.credentials ?? {}).reduce<{ [key: string]: Credentials }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Credentials.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.requiredResources = Object.entries(object.requiredResources ?? {}).reduce<{ [key: string]: Resources }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Resources.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRunFunctionRequest_ExtraResourcesEntry(): RunFunctionRequest_ExtraResourcesEntry {
  return { key: "", value: undefined };
}

export const RunFunctionRequest_ExtraResourcesEntry: MessageFns<RunFunctionRequest_ExtraResourcesEntry> = {
  encode(message: RunFunctionRequest_ExtraResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Resources.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest_ExtraResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest_ExtraResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Resources.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest_ExtraResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Resources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunFunctionRequest_ExtraResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Resources.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunFunctionRequest_ExtraResourcesEntry>, I>>(
    base?: I,
  ): RunFunctionRequest_ExtraResourcesEntry {
    return RunFunctionRequest_ExtraResourcesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFunctionRequest_ExtraResourcesEntry>, I>>(
    object: I,
  ): RunFunctionRequest_ExtraResourcesEntry {
    const message = createBaseRunFunctionRequest_ExtraResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Resources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRunFunctionRequest_CredentialsEntry(): RunFunctionRequest_CredentialsEntry {
  return { key: "", value: undefined };
}

export const RunFunctionRequest_CredentialsEntry: MessageFns<RunFunctionRequest_CredentialsEntry> = {
  encode(message: RunFunctionRequest_CredentialsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Credentials.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest_CredentialsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest_CredentialsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Credentials.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest_CredentialsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Credentials.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunFunctionRequest_CredentialsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Credentials.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunFunctionRequest_CredentialsEntry>, I>>(
    base?: I,
  ): RunFunctionRequest_CredentialsEntry {
    return RunFunctionRequest_CredentialsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFunctionRequest_CredentialsEntry>, I>>(
    object: I,
  ): RunFunctionRequest_CredentialsEntry {
    const message = createBaseRunFunctionRequest_CredentialsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Credentials.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRunFunctionRequest_RequiredResourcesEntry(): RunFunctionRequest_RequiredResourcesEntry {
  return { key: "", value: undefined };
}

export const RunFunctionRequest_RequiredResourcesEntry: MessageFns<RunFunctionRequest_RequiredResourcesEntry> = {
  encode(message: RunFunctionRequest_RequiredResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Resources.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionRequest_RequiredResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionRequest_RequiredResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Resources.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionRequest_RequiredResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Resources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunFunctionRequest_RequiredResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Resources.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunFunctionRequest_RequiredResourcesEntry>, I>>(
    base?: I,
  ): RunFunctionRequest_RequiredResourcesEntry {
    return RunFunctionRequest_RequiredResourcesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFunctionRequest_RequiredResourcesEntry>, I>>(
    object: I,
  ): RunFunctionRequest_RequiredResourcesEntry {
    const message = createBaseRunFunctionRequest_RequiredResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Resources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCredentials(): Credentials {
  return { credentialData: undefined };
}

export const Credentials: MessageFns<Credentials> = {
  encode(message: Credentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentialData !== undefined) {
      CredentialData.encode(message.credentialData, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.credentialData = CredentialData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credentials {
    return {
      credentialData: isSet(object.credentialData) ? CredentialData.fromJSON(object.credentialData) : undefined,
    };
  },

  toJSON(message: Credentials): unknown {
    const obj: any = {};
    if (message.credentialData !== undefined) {
      obj.credentialData = CredentialData.toJSON(message.credentialData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Credentials>, I>>(base?: I): Credentials {
    return Credentials.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Credentials>, I>>(object: I): Credentials {
    const message = createBaseCredentials();
    message.credentialData = (object.credentialData !== undefined && object.credentialData !== null)
      ? CredentialData.fromPartial(object.credentialData)
      : undefined;
    return message;
  },
};

function createBaseCredentialData(): CredentialData {
  return { data: {} };
}

export const CredentialData: MessageFns<CredentialData> = {
  encode(message: CredentialData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.data).forEach(([key, value]) => {
      CredentialData_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CredentialData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentialData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = CredentialData_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CredentialData {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: Buffer }>((acc, [key, value]) => {
          acc[key] = Buffer.from(bytesFromBase64(value as string));
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CredentialData): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CredentialData>, I>>(base?: I): CredentialData {
    return CredentialData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CredentialData>, I>>(object: I): CredentialData {
    const message = createBaseCredentialData();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: Buffer }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCredentialData_DataEntry(): CredentialData_DataEntry {
  return { key: "", value: Buffer.alloc(0) };
}

export const CredentialData_DataEntry: MessageFns<CredentialData_DataEntry> = {
  encode(message: CredentialData_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CredentialData_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentialData_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CredentialData_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: CredentialData_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CredentialData_DataEntry>, I>>(base?: I): CredentialData_DataEntry {
    return CredentialData_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CredentialData_DataEntry>, I>>(object: I): CredentialData_DataEntry {
    const message = createBaseCredentialData_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseResources(): Resources {
  return { items: [] };
}

export const Resources: MessageFns<Resources> = {
  encode(message: Resources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Resource.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Resource.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resources {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Resource.fromJSON(e)) : [] };
  },

  toJSON(message: Resources): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Resource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resources>, I>>(base?: I): Resources {
    return Resources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resources>, I>>(object: I): Resources {
    const message = createBaseResources();
    message.items = object.items?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunFunctionResponse(): RunFunctionResponse {
  return {
    meta: undefined,
    desired: undefined,
    results: [],
    context: undefined,
    requirements: undefined,
    conditions: [],
    output: undefined,
  };
}

export const RunFunctionResponse: MessageFns<RunFunctionResponse> = {
  encode(message: RunFunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meta !== undefined) {
      ResponseMeta.encode(message.meta, writer.uint32(10).fork()).join();
    }
    if (message.desired !== undefined) {
      State.encode(message.desired, writer.uint32(18).fork()).join();
    }
    for (const v of message.results) {
      Result.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(34).fork()).join();
    }
    if (message.requirements !== undefined) {
      Requirements.encode(message.requirements, writer.uint32(42).fork()).join();
    }
    for (const v of message.conditions) {
      Condition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.output !== undefined) {
      Struct.encode(Struct.wrap(message.output), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meta = ResponseMeta.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.desired = State.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.results.push(Result.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requirements = Requirements.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunctionResponse {
    return {
      meta: isSet(object.meta) ? ResponseMeta.fromJSON(object.meta) : undefined,
      desired: isSet(object.desired) ? State.fromJSON(object.desired) : undefined,
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => Result.fromJSON(e)) : [],
      context: isObject(object.context) ? object.context : undefined,
      requirements: isSet(object.requirements) ? Requirements.fromJSON(object.requirements) : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
      output: isObject(object.output) ? object.output : undefined,
    };
  },

  toJSON(message: RunFunctionResponse): unknown {
    const obj: any = {};
    if (message.meta !== undefined) {
      obj.meta = ResponseMeta.toJSON(message.meta);
    }
    if (message.desired !== undefined) {
      obj.desired = State.toJSON(message.desired);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => Result.toJSON(e));
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.requirements !== undefined) {
      obj.requirements = Requirements.toJSON(message.requirements);
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    if (message.output !== undefined) {
      obj.output = message.output;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunFunctionResponse>, I>>(base?: I): RunFunctionResponse {
    return RunFunctionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunFunctionResponse>, I>>(object: I): RunFunctionResponse {
    const message = createBaseRunFunctionResponse();
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? ResponseMeta.fromPartial(object.meta)
      : undefined;
    message.desired = (object.desired !== undefined && object.desired !== null)
      ? State.fromPartial(object.desired)
      : undefined;
    message.results = object.results?.map((e) => Result.fromPartial(e)) || [];
    message.context = object.context ?? undefined;
    message.requirements = (object.requirements !== undefined && object.requirements !== null)
      ? Requirements.fromPartial(object.requirements)
      : undefined;
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    message.output = object.output ?? undefined;
    return message;
  },
};

function createBaseRequestMeta(): RequestMeta {
  return { tag: "" };
}

export const RequestMeta: MessageFns<RequestMeta> = {
  encode(message: RequestMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMeta {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: RequestMeta): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestMeta>, I>>(base?: I): RequestMeta {
    return RequestMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestMeta>, I>>(object: I): RequestMeta {
    const message = createBaseRequestMeta();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseRequirements(): Requirements {
  return { extraResources: {}, resources: {} };
}

export const Requirements: MessageFns<Requirements> = {
  encode(message: Requirements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.extraResources).forEach(([key, value]) => {
      Requirements_ExtraResourcesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.resources).forEach(([key, value]) => {
      Requirements_ResourcesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Requirements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Requirements_ExtraResourcesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.extraResources[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Requirements_ResourcesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.resources[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Requirements {
    return {
      extraResources: isObject(object.extraResources)
        ? Object.entries(object.extraResources).reduce<{ [key: string]: ResourceSelector }>((acc, [key, value]) => {
          acc[key] = ResourceSelector.fromJSON(value);
          return acc;
        }, {})
        : {},
      resources: isObject(object.resources)
        ? Object.entries(object.resources).reduce<{ [key: string]: ResourceSelector }>((acc, [key, value]) => {
          acc[key] = ResourceSelector.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Requirements): unknown {
    const obj: any = {};
    if (message.extraResources) {
      const entries = Object.entries(message.extraResources);
      if (entries.length > 0) {
        obj.extraResources = {};
        entries.forEach(([k, v]) => {
          obj.extraResources[k] = ResourceSelector.toJSON(v);
        });
      }
    }
    if (message.resources) {
      const entries = Object.entries(message.resources);
      if (entries.length > 0) {
        obj.resources = {};
        entries.forEach(([k, v]) => {
          obj.resources[k] = ResourceSelector.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Requirements>, I>>(base?: I): Requirements {
    return Requirements.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Requirements>, I>>(object: I): Requirements {
    const message = createBaseRequirements();
    message.extraResources = Object.entries(object.extraResources ?? {}).reduce<{ [key: string]: ResourceSelector }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ResourceSelector.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.resources = Object.entries(object.resources ?? {}).reduce<{ [key: string]: ResourceSelector }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ResourceSelector.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRequirements_ExtraResourcesEntry(): Requirements_ExtraResourcesEntry {
  return { key: "", value: undefined };
}

export const Requirements_ExtraResourcesEntry: MessageFns<Requirements_ExtraResourcesEntry> = {
  encode(message: Requirements_ExtraResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ResourceSelector.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Requirements_ExtraResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirements_ExtraResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ResourceSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Requirements_ExtraResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ResourceSelector.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Requirements_ExtraResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ResourceSelector.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Requirements_ExtraResourcesEntry>, I>>(
    base?: I,
  ): Requirements_ExtraResourcesEntry {
    return Requirements_ExtraResourcesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Requirements_ExtraResourcesEntry>, I>>(
    object: I,
  ): Requirements_ExtraResourcesEntry {
    const message = createBaseRequirements_ExtraResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ResourceSelector.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRequirements_ResourcesEntry(): Requirements_ResourcesEntry {
  return { key: "", value: undefined };
}

export const Requirements_ResourcesEntry: MessageFns<Requirements_ResourcesEntry> = {
  encode(message: Requirements_ResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ResourceSelector.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Requirements_ResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequirements_ResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ResourceSelector.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Requirements_ResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ResourceSelector.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Requirements_ResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ResourceSelector.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Requirements_ResourcesEntry>, I>>(base?: I): Requirements_ResourcesEntry {
    return Requirements_ResourcesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Requirements_ResourcesEntry>, I>>(object: I): Requirements_ResourcesEntry {
    const message = createBaseRequirements_ResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ResourceSelector.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResourceSelector(): ResourceSelector {
  return { apiVersion: "", kind: "", matchName: undefined, matchLabels: undefined, namespace: undefined };
}

export const ResourceSelector: MessageFns<ResourceSelector> = {
  encode(message: ResourceSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.matchName !== undefined) {
      writer.uint32(26).string(message.matchName);
    }
    if (message.matchLabels !== undefined) {
      MatchLabels.encode(message.matchLabels, writer.uint32(34).fork()).join();
    }
    if (message.namespace !== undefined) {
      writer.uint32(42).string(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matchName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchLabels = MatchLabels.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSelector {
    return {
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      matchName: isSet(object.matchName) ? globalThis.String(object.matchName) : undefined,
      matchLabels: isSet(object.matchLabels) ? MatchLabels.fromJSON(object.matchLabels) : undefined,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : undefined,
    };
  },

  toJSON(message: ResourceSelector): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.matchName !== undefined) {
      obj.matchName = message.matchName;
    }
    if (message.matchLabels !== undefined) {
      obj.matchLabels = MatchLabels.toJSON(message.matchLabels);
    }
    if (message.namespace !== undefined) {
      obj.namespace = message.namespace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceSelector>, I>>(base?: I): ResourceSelector {
    return ResourceSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceSelector>, I>>(object: I): ResourceSelector {
    const message = createBaseResourceSelector();
    message.apiVersion = object.apiVersion ?? "";
    message.kind = object.kind ?? "";
    message.matchName = object.matchName ?? undefined;
    message.matchLabels = (object.matchLabels !== undefined && object.matchLabels !== null)
      ? MatchLabels.fromPartial(object.matchLabels)
      : undefined;
    message.namespace = object.namespace ?? undefined;
    return message;
  },
};

function createBaseMatchLabels(): MatchLabels {
  return { labels: {} };
}

export const MatchLabels: MessageFns<MatchLabels> = {
  encode(message: MatchLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      MatchLabels_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MatchLabels_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchLabels {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MatchLabels): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchLabels>, I>>(base?: I): MatchLabels {
    return MatchLabels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchLabels>, I>>(object: I): MatchLabels {
    const message = createBaseMatchLabels();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMatchLabels_LabelsEntry(): MatchLabels_LabelsEntry {
  return { key: "", value: "" };
}

export const MatchLabels_LabelsEntry: MessageFns<MatchLabels_LabelsEntry> = {
  encode(message: MatchLabels_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchLabels_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchLabels_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchLabels_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MatchLabels_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchLabels_LabelsEntry>, I>>(base?: I): MatchLabels_LabelsEntry {
    return MatchLabels_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchLabels_LabelsEntry>, I>>(object: I): MatchLabels_LabelsEntry {
    const message = createBaseMatchLabels_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResponseMeta(): ResponseMeta {
  return { tag: "", ttl: undefined };
}

export const ResponseMeta: MessageFns<ResponseMeta> = {
  encode(message: ResponseMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMeta {
    return {
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: ResponseMeta): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseMeta>, I>>(base?: I): ResponseMeta {
    return ResponseMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseMeta>, I>>(object: I): ResponseMeta {
    const message = createBaseResponseMeta();
    message.tag = object.tag ?? "";
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseState(): State {
  return { composite: undefined, resources: {} };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.composite !== undefined) {
      Resource.encode(message.composite, writer.uint32(10).fork()).join();
    }
    Object.entries(message.resources).forEach(([key, value]) => {
      State_ResourcesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.composite = Resource.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = State_ResourcesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.resources[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State {
    return {
      composite: isSet(object.composite) ? Resource.fromJSON(object.composite) : undefined,
      resources: isObject(object.resources)
        ? Object.entries(object.resources).reduce<{ [key: string]: Resource }>((acc, [key, value]) => {
          acc[key] = Resource.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    if (message.composite !== undefined) {
      obj.composite = Resource.toJSON(message.composite);
    }
    if (message.resources) {
      const entries = Object.entries(message.resources);
      if (entries.length > 0) {
        obj.resources = {};
        entries.forEach(([k, v]) => {
          obj.resources[k] = Resource.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<State>, I>>(base?: I): State {
    return State.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<State>, I>>(object: I): State {
    const message = createBaseState();
    message.composite = (object.composite !== undefined && object.composite !== null)
      ? Resource.fromPartial(object.composite)
      : undefined;
    message.resources = Object.entries(object.resources ?? {}).reduce<{ [key: string]: Resource }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Resource.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseState_ResourcesEntry(): State_ResourcesEntry {
  return { key: "", value: undefined };
}

export const State_ResourcesEntry: MessageFns<State_ResourcesEntry> = {
  encode(message: State_ResourcesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Resource.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State_ResourcesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState_ResourcesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Resource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State_ResourcesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Resource.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: State_ResourcesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Resource.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<State_ResourcesEntry>, I>>(base?: I): State_ResourcesEntry {
    return State_ResourcesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<State_ResourcesEntry>, I>>(object: I): State_ResourcesEntry {
    const message = createBaseState_ResourcesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Resource.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResource(): Resource {
  return { resource: undefined, connectionDetails: {}, ready: 0 };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== undefined) {
      Struct.encode(Struct.wrap(message.resource), writer.uint32(10).fork()).join();
    }
    Object.entries(message.connectionDetails).forEach(([key, value]) => {
      Resource_ConnectionDetailsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.ready !== 0) {
      writer.uint32(24).int32(message.ready);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Resource_ConnectionDetailsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.connectionDetails[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ready = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      resource: isObject(object.resource) ? object.resource : undefined,
      connectionDetails: isObject(object.connectionDetails)
        ? Object.entries(object.connectionDetails).reduce<{ [key: string]: Buffer }>((acc, [key, value]) => {
          acc[key] = Buffer.from(bytesFromBase64(value as string));
          return acc;
        }, {})
        : {},
      ready: isSet(object.ready) ? readyFromJSON(object.ready) : 0,
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.resource !== undefined) {
      obj.resource = message.resource;
    }
    if (message.connectionDetails) {
      const entries = Object.entries(message.connectionDetails);
      if (entries.length > 0) {
        obj.connectionDetails = {};
        entries.forEach(([k, v]) => {
          obj.connectionDetails[k] = base64FromBytes(v);
        });
      }
    }
    if (message.ready !== 0) {
      obj.ready = readyToJSON(message.ready);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.resource = object.resource ?? undefined;
    message.connectionDetails = Object.entries(object.connectionDetails ?? {}).reduce<{ [key: string]: Buffer }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.ready = object.ready ?? 0;
    return message;
  },
};

function createBaseResource_ConnectionDetailsEntry(): Resource_ConnectionDetailsEntry {
  return { key: "", value: Buffer.alloc(0) };
}

export const Resource_ConnectionDetailsEntry: MessageFns<Resource_ConnectionDetailsEntry> = {
  encode(message: Resource_ConnectionDetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource_ConnectionDetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_ConnectionDetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource_ConnectionDetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Resource_ConnectionDetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource_ConnectionDetailsEntry>, I>>(base?: I): Resource_ConnectionDetailsEntry {
    return Resource_ConnectionDetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource_ConnectionDetailsEntry>, I>>(
    object: I,
  ): Resource_ConnectionDetailsEntry {
    const message = createBaseResource_ConnectionDetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseResult(): Result {
  return { severity: 0, message: "", reason: undefined, target: undefined };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.target !== undefined) {
      writer.uint32(32).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      target: isSet(object.target) ? targetFromJSON(object.target) : undefined,
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.target !== undefined) {
      obj.target = targetToJSON(message.target);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.severity = object.severity ?? 0;
    message.message = object.message ?? "";
    message.reason = object.reason ?? undefined;
    message.target = object.target ?? undefined;
    return message;
  },
};

function createBaseCondition(): Condition {
  return { type: "", status: 0, reason: "", message: undefined, target: undefined };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.message !== undefined) {
      writer.uint32(34).string(message.message);
    }
    if (message.target !== undefined) {
      writer.uint32(40).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      target: isSet(object.target) ? targetFromJSON(object.target) : undefined,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.target !== undefined) {
      obj.target = targetToJSON(message.target);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Condition>, I>>(base?: I): Condition {
    return Condition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Condition>, I>>(object: I): Condition {
    const message = createBaseCondition();
    message.type = object.type ?? "";
    message.status = object.status ?? 0;
    message.reason = object.reason ?? "";
    message.message = object.message ?? undefined;
    message.target = object.target ?? undefined;
    return message;
  },
};

/** A FunctionRunnerService is a function. */
export type FunctionRunnerServiceService = typeof FunctionRunnerServiceService;
export const FunctionRunnerServiceService = {
  /** RunFunction runs the function. */
  runFunction: {
    path: "/apiextensions.fn.proto.v1.FunctionRunnerService/RunFunction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunFunctionRequest): Buffer => Buffer.from(RunFunctionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunFunctionRequest => RunFunctionRequest.decode(value),
    responseSerialize: (value: RunFunctionResponse): Buffer => Buffer.from(RunFunctionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunFunctionResponse => RunFunctionResponse.decode(value),
  },
} as const;

export interface FunctionRunnerServiceServer extends UntypedServiceImplementation {
  /** RunFunction runs the function. */
  runFunction: handleUnaryCall<RunFunctionRequest, RunFunctionResponse>;
}

export interface FunctionRunnerServiceClient extends Client {
  /** RunFunction runs the function. */
  runFunction(
    request: RunFunctionRequest,
    callback: (error: ServiceError | null, response: RunFunctionResponse) => void,
  ): ClientUnaryCall;
  runFunction(
    request: RunFunctionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RunFunctionResponse) => void,
  ): ClientUnaryCall;
  runFunction(
    request: RunFunctionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RunFunctionResponse) => void,
  ): ClientUnaryCall;
}

export const FunctionRunnerServiceClient = makeGenericClientConstructor(
  FunctionRunnerServiceService,
  "apiextensions.fn.proto.v1.FunctionRunnerService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): FunctionRunnerServiceClient;
  service: typeof FunctionRunnerServiceService;
  serviceName: string;
};

export interface DataLoaderOptions {
  cache?: boolean;
}

export interface DataLoaders {
  rpcDataLoaderOptions?: DataLoaderOptions;
  getDataLoader<T>(identifier: string, constructorFn: () => T): T;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
